#include <Wire.h>

#define OLED_ADDRESS 0x3C // I2C address of the OLED display
#define SCREEN_WIDTH 64   // Width of the OLED screen in pixels
#define SCREEN_HEIGHT 32  // Height of the OLED screen in pixels

byte screenBuffer[SCREEN_WIDTH * SCREEN_HEIGHT / 8]; // Off-screen buffer for double buffering

// 'clock', 35x11px
const unsigned char img_clock [] PROGMEM = {
	0xf8, 0x04, 0x02, 0x01, 0x01, 0x3d, 0x21, 0x21, 0x02, 0x04, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x04, 
	0x04, 0xfc, 0x04, 0x04, 0x00, 0xfc, 0x00, 0xfc, 0x04, 0xfc, 0x04, 0x04, 0xf8, 0x00, 0xfc, 0x24, 
	0x24, 0x24, 0x24, 0x00, 0x01, 0x02, 0x04, 0x04, 0x04, 0x04, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x01, 0x01, 0x01, 0x01
};
// 'games', 45x8px
const unsigned char img_games [] PROGMEM = {
	0x70, 0x18, 0x7d, 0xb6, 0xbc, 0x3c, 0xbc, 0xb6, 0x7d, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00, 0x7f, 
	0x41, 0x41, 0x49, 0x79, 0x00, 0x7f, 0x09, 0x09, 0x09, 0x7f, 0x00, 0x7f, 0x01, 0x7f, 0x01, 0x01, 
	0x7e, 0x00, 0x7f, 0x49, 0x49, 0x49, 0x49, 0x00, 0x4f, 0x49, 0x49, 0x49, 0x79
};
// 'omnitrix', 54x11px
const unsigned char img_omnitrix [] PROGMEM = {
	0x03, 0x07, 0x8f, 0xdf, 0xff, 0xdf, 0x8f, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x04, 
	0x04, 0x04, 0xfc, 0x00, 0xfc, 0x04, 0xfc, 0x04, 0x04, 0xf8, 0x00, 0xfc, 0x04, 0x04, 0x04, 0xf8, 
	0x00, 0xfc, 0x00, 0x04, 0x04, 0xfc, 0x04, 0x04, 0x00, 0xfc, 0x24, 0x24, 0x24, 0xd8, 0x00, 0xfc, 
	0x00, 0xdc, 0x20, 0x20, 0x20, 0xdc, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01
};
// 'weather', 54x11px
const unsigned char img_weather [] PROGMEM = {
	0x80, 0x7e, 0x01, 0x7e, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0xfc, 0x00, 
	0x00, 0xfc, 0x00, 0xfc, 0x24, 0x24, 0x24, 0x24, 0x00, 0xfc, 0x24, 0x24, 0x24, 0xfc, 0x00, 0x04, 
	0x04, 0xfc, 0x04, 0x04, 0x00, 0xfc, 0x20, 0x20, 0x20, 0xfc, 0x00, 0xfc, 0x24, 0x24, 0x24, 0x24, 
	0x00, 0xfc, 0x24, 0x24, 0x24, 0xd8, 0x03, 0x04, 0x05, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
	0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01
};
// 'select', 60x15px
const unsigned char img_select [] PROGMEM = {
	0xfc, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0xfc, 0x1f, 0x20, 0x40, 0x40, 
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x20, 0x1f
};

uint8_t selected_item = 0;
uint8_t next_item = selected_item + 1;

const uint8_t buttonPin = 2;

// Function to send a command to the OLED display
void sendCommand(byte command) {
  Wire.beginTransmission(OLED_ADDRESS);
  Wire.write(0x00); // Control byte indicating command
  Wire.write(command);
  Wire.endTransmission();
}

// Function to send data to the OLED display
void sendData(byte data) {
  Wire.beginTransmission(OLED_ADDRESS);
  Wire.write(0x40); // Control byte indicating data
  Wire.write(data);
  Wire.endTransmission();
}

void setup() {
  pinMode(buttonPin, INPUT_PULLUP);

  Wire.begin();

  // Initialize the OLED display
  sendCommand(0xAE); // Display off

  sendCommand(0x20); // Set memory addressing mode
  sendCommand(0x10); // Horizontal addressing mode

  sendCommand(0xB0); // Set page start address
  sendCommand(0);    // Page 0

  sendCommand(0xC8); // Set COM output scan direction

  sendCommand(0x00); // Set lower column start address
  sendCommand(0x10); // Set higher column start address

  sendCommand(0x40); // Set display start line

  sendCommand(0x81); // Set contrast control
  sendCommand(0xFF); // Maximum contrast

  sendCommand(0xA1); // Set segment remap
  sendCommand(0xA6); // Set normal display

  sendCommand(0xA8); // Set multiplex ratio
  sendCommand(0x1F); // 1/32 duty cycle

  sendCommand(0xA4); // Set entire display on/off
  sendCommand(0xD3); // Set display offset
  sendCommand(0x00);

  sendCommand(0xDA); // Set COM pins hardware configuration
  sendCommand(0x12);

  sendCommand(0xD5); // Set display clock divide ratio/oscillator frequency
  sendCommand(0x80);

  sendCommand(0x8D); // Enable charge pump regulator
  sendCommand(0x14);

  sendCommand(0xAF); // Display on
}

void clearScreen() {
  memset(screenBuffer, 0, sizeof(screenBuffer));
}

// Load buffer memory to the OLED itself
void updateScreen() {
  for (int page = 0; page < SCREEN_HEIGHT / 8; page++) {
    sendCommand(0xB0 + page); // Set page address
    sendCommand(0x00);        // Set lower column start address
    sendCommand(0x12);        // Set higher column start address

    for (int column = 0; column < SCREEN_WIDTH; column++) {
      sendData(screenBuffer[column + page * SCREEN_WIDTH]);
    }
  }
}

void drawPixel(uint8_t x, uint8_t y) {
  if (x >= 0 && x < SCREEN_WIDTH && y >= 0 && y < SCREEN_HEIGHT) {
    int bufferIndex = x + (y / 8) * SCREEN_WIDTH;
    screenBuffer[bufferIndex] |= (1 << (y % 8));
  }
}

// Function to draw an image from a bitmap array onto the OLED display
void drawImage(uint8_t x, uint8_t y, const byte* image, uint8_t imageWidth, uint8_t imageHeight) {
  // Ensure the image fits within the screen dimensions
  if (x >= 0 && x + imageWidth <= SCREEN_WIDTH && y >= 0 && y + imageHeight <= SCREEN_HEIGHT) {
    for (int j = 0; j < imageHeight; j++) {
      for (int i = 0; i < imageWidth; i++) {
        // Get the byte containing the pixel data from the image
        byte imageData = pgm_read_byte(&image[i + (j / 8) * imageWidth]);

        // Calculate the screen buffer coordinates
        int screenX = x + i;
        int screenY = y + j;

        // Calculate the bit position within the byte
        int bitPosition = j % 8;

        // Check if the bit at the specified position is set
        bool pixelOn = (imageData & (1 << bitPosition)) != 0;

        // Draw the pixel on the screen buffer
        if (pixelOn) {
          drawPixel(screenX, screenY); // Set pixel to ON
        }
      }
    }
  }
}

void loop() {
  int buttonState = digitalRead(buttonPin); // Read the button state

  // Check if the button is pressed (LOW)
  if (buttonState == LOW) {
    selected_item++;
  }

  delay(70); // Delay for debounce (adjust as needed)

  if (selected_item == 0) {
    // Go to state "time"
    clearScreen();
    drawImage(1, 0, img_select, 60, 15);
    drawImage(3, 2, img_clock, 35, 11);
    drawImage(3, 21, img_games, 45, 8);

    updateScreen();
  }
  else if (selected_item == 1) {
    // Go to state "game_menu"
    clearScreen();
    drawImage(1, 0, img_select, 60, 15);
    drawImage(3, 3, img_games, 45, 8);
    drawImage(3, 21, img_omnitrix, 54, 11);

    updateScreen();
  }
  else if (selected_item == 2) {
    // Go to state "omnitrix"
    clearScreen();
    drawImage(1, 0, img_select, 60, 15);
    drawImage(3, 2, img_omnitrix, 54, 11);
    drawImage(3, 19, img_weather, 54, 11);

    updateScreen();
  }
  else if (selected_item == 3) {
    // Go to state "weather"
    clearScreen();
    drawImage(3, 2, img_omnitrix, 54, 11);
    drawImage(1, 17, img_select, 60, 15);
    drawImage(3, 19, img_weather, 54, 11);

    updateScreen();
  }
  else {selected_item = 0;}
}
